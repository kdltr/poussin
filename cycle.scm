;; --> (before-cycle length cycle cycle-length)
(define (split l)
  (define (find-cycle cursor pairs cur-len max-len)
    (cond ((not (pair? cursor))
           (list l max-len '() 0))
          ((eqv? pairs cursor)
           (if (> max-len cur-len)
               (list (take l cur-len) cur-len cursor (- max-len cur-len))
               (find-cycle (cdr cursor) l 0 (+ max-len 1))))
          (else
            (find-cycle cursor (cdr pairs) (+ cur-len 1) max-len))))
  (find-cycle l l 0 0))

(define (kernel-equal? o1 o2)
  (cond ((and (pair? o1) (pair? o2))
         (let* ((o1-spec (split o1))
                (o1-noncycle (first o1-spec))
                (o1-noncycle-len (second o1-spec))
                (o1-cycle (third o1-spec))
                (o1-cycle-len (fourth o1-spec))
                (o2-spec (split o2))
                (o2-noncycle (first o2-spec))
                (o2-noncycle-len (second o2-spec))
                (o2-cycle (third o2-spec))
                (o2-cycle-len (fourth o2-spec)))
           (cond ((and (zero? o1-cycle-len)
                       (zero? o2-cycle-len))
                  (fold (lambda (o1 o2 rest)
                          (and rest
                               (kernel-equal? o1 o2)))
                        #t
                        o1 o2))
                 ((or (zero? o1-cycle-len)
                      (zero? o2-cycle-len))
                  #f)
                 (else
                   (let ((o1-minlen (+ o1-noncycle-len o1-cycle-len))
                         (o2-minlen (+ o2-noncycle-len o2-cycle-len)))
                     (let lp ((n (max o1-minlen o2-minlen))
                              (o1 o1)
                              (o2 o2))
                       (if (zero? n)
                           #t
                           (and (kernel-equal? (car o1) (car o2))
                                (lp (- n 1) (cdr o1) (cdr o2)))))))

                 )))
        (else (equal? o1 o2))))

